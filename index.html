/**
 * Nowak's Distributing - Relational Database Backend
 * Version 3.0 - CORS FIXED (Proper Method)
 * 
 * IMPORTANT: Google Apps Script web apps automatically handle CORS
 * when deployed with "Anyone" access. The issue is likely the deployment settings.
 * 
 * INSTALLATION:
 * 1. Open your "Nowak Distributing Master" spreadsheet
 * 2. Go to Extensions → Apps Script
 * 3. SELECT ALL existing code and DELETE it
 * 4. Paste this entire script
 * 5. Click Save (disk icon)
 * 6. Click Deploy → New deployment (NOT manage deployments)
 * 7. Type: Web app
 * 8. Description: "v3 - CORS fixed"
 * 9. Execute as: Me
 * 10. Who has access: Anyone
 * 11. Click Deploy
 * 12. Copy the NEW Web App URL and update it in your frontend Settings!
 */

// ==================== UTILITY FUNCTIONS ====================

function doGet(e) {
  // Handle API calls via GET to avoid CORS preflight issues
  if (e.parameter && e.parameter.action) {
    try {
      const action = e.parameter.action;
      const data = e.parameter.data ? JSON.parse(e.parameter.data) : {};
      
      // Route to appropriate handler (same as doPost)
      let result;
      switch (action) {
        // Supplier operations
        case 'addSupplier':
          result = addSupplier(data);
          break;
        case 'updateSupplier':
          result = updateSupplier(data);
          break;
        case 'deleteSupplier':
          result = deleteSupplier(data);
          break;
        case 'getSuppliers':
          result = getSuppliers();
          break;
        
        // Item operations
        case 'addItem':
          result = addItem(data);
          break;
        case 'updateItem':
          result = updateItem(data);
          break;
        case 'deleteItem':
          result = deleteItem(data);
          break;
        case 'getItems':
          result = getItems();
          break;
        
        // Customer operations
        case 'addCustomer':
          result = addCustomer(data);
          break;
        case 'updateCustomer':
          result = updateCustomer(data);
          break;
        case 'deleteCustomer':
          result = deleteCustomer(data);
          break;
        case 'getCustomers':
          result = getCustomers();
          break;
        
        // Purchase Order operations
        case 'createPurchaseOrder':
          result = createPurchaseOrder(data);
          break;
        case 'getPurchaseOrders':
          result = getPurchaseOrders();
          break;
        
        // Sales Order operations
        case 'createSalesOrder':
          result = createSalesOrder(data);
          break;
        case 'getSalesOrders':
          result = getSalesOrders();
          break;
        
        // Inventory operations
        case 'adjustInventory':
          result = adjustInventory(data);
          break;
        case 'getInventoryReport':
          result = getInventoryReport();
          break;
        
        default:
          result = {
            status: 'error',
            message: 'Unknown action: ' + action
          };
      }
      
      return ContentService
        .createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
        
    } catch (error) {
      return ContentService
        .createTextOutput(JSON.stringify({
          status: 'error',
          message: error.toString()
        }))
        .setMimeType(ContentService.MimeType.JSON);
    }
  }
  
  // Default response for testing
  const response = {
    status: 'success',
    message: 'Nowak\'s Distributing Relational API v3.0',
    timestamp: new Date().toISOString(),
    note: 'Use GET with action and data parameters'
  };
  
  return ContentService
    .createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const action = data.action;
    
    // Route to appropriate handler
    let result;
    switch (action) {
      // Supplier operations
      case 'addSupplier':
        result = addSupplier(data);
        break;
      case 'updateSupplier':
        result = updateSupplier(data);
        break;
      case 'deleteSupplier':
        result = deleteSupplier(data);
        break;
      case 'getSuppliers':
        result = getSuppliers();
        break;
      
      // Item operations
      case 'addItem':
        result = addItem(data);
        break;
      case 'updateItem':
        result = updateItem(data);
        break;
      case 'deleteItem':
        result = deleteItem(data);
        break;
      case 'getItems':
        result = getItems();
        break;
      
      // Customer operations
      case 'addCustomer':
        result = addCustomer(data);
        break;
      case 'updateCustomer':
        result = updateCustomer(data);
        break;
      case 'deleteCustomer':
        result = deleteCustomer(data);
        break;
      case 'getCustomers':
        result = getCustomers();
        break;
      
      // Purchase Order operations
      case 'createPurchaseOrder':
        result = createPurchaseOrder(data);
        break;
      case 'getPurchaseOrders':
        result = getPurchaseOrders();
        break;
      
      // Sales Order operations
      case 'createSalesOrder':
        result = createSalesOrder(data);
        break;
      case 'getSalesOrders':
        result = getSalesOrders();
        break;
      
      // Inventory operations
      case 'adjustInventory':
        result = adjustInventory(data);
        break;
      case 'getInventoryReport':
        result = getInventoryReport();
        break;
      
      default:
        result = {
          status: 'error',
          message: 'Unknown action: ' + action
        };
    }
    
    return ContentService
      .createTextOutput(JSON.stringify(result))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    return ContentService
      .createTextOutput(JSON.stringify({
        status: 'error',
        message: error.toString()
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function getSpreadsheet() {
  return SpreadsheetApp.getActiveSpreadsheet();
}

function getSheet(sheetName) {
  return getSpreadsheet().getSheetByName(sheetName);
}

function generateId(prefix, sheet) {
  const data = sheet.getDataRange().getValues();
  if (data.length <= 1) return prefix + '001';
  
  const ids = data.slice(1).map(row => row[0]).filter(id => id);
  if (ids.length === 0) return prefix + '001';
  
  const numbers = ids.map(id => parseInt(id.replace(prefix, ''))).filter(n => !isNaN(n));
  const maxNum = Math.max(...numbers);
  return prefix + String(maxNum + 1).padStart(3, '0');
}

// ==================== SUPPLIER OPERATIONS ====================

function getSuppliers() {
  try {
    const sheet = getSheet('Suppliers');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const suppliers = data.slice(1).map(row => {
      const supplier = {};
      headers.forEach((header, index) => {
        supplier[header] = row[index];
      });
      return supplier;
    }).filter(s => s.Supplier_ID);
    
    return {
      status: 'success',
      data: suppliers
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function addSupplier(data) {
  try {
    const sheet = getSheet('Suppliers');
    const supplierId = generateId('S', sheet);
    
    const newRow = [
      supplierId,
      data.name || '',
      data.address || '',
      data.city || '',
      data.state || '',
      data.zip || '',
      data.contactName || '',
      data.phone || '',
      data.fax || '',
      data.email || '',
      data.paymentTerms || 'Net 30',
      data.notes || ''
    ];
    
    sheet.appendRow(newRow);
    
    return {
      status: 'success',
      message: 'Supplier added successfully',
      supplierId: supplierId
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function updateSupplier(data) {
  try {
    const sheet = getSheet('Suppliers');
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    
    for (let i = 1; i < values.length; i++) {
      if (values[i][0] === data.supplierId) {
        sheet.getRange(i + 1, 2).setValue(data.name || values[i][1]);
        sheet.getRange(i + 1, 3).setValue(data.address || values[i][2]);
        sheet.getRange(i + 1, 4).setValue(data.city || values[i][3]);
        sheet.getRange(i + 1, 5).setValue(data.state || values[i][4]);
        sheet.getRange(i + 1, 6).setValue(data.zip || values[i][5]);
        sheet.getRange(i + 1, 7).setValue(data.contactName || values[i][6]);
        sheet.getRange(i + 1, 8).setValue(data.phone || values[i][7]);
        sheet.getRange(i + 1, 9).setValue(data.fax || values[i][8]);
        sheet.getRange(i + 1, 10).setValue(data.email || values[i][9]);
        sheet.getRange(i + 1, 11).setValue(data.paymentTerms || values[i][10]);
        sheet.getRange(i + 1, 12).setValue(data.notes || values[i][11]);
        
        return {
          status: 'success',
          message: 'Supplier updated successfully'
        };
      }
    }
    
    return {
      status: 'error',
      message: 'Supplier not found'
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function deleteSupplier(data) {
  try {
    const sheet = getSheet('Suppliers');
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    
    for (let i = 1; i < values.length; i++) {
      if (values[i][0] === data.supplierId) {
        sheet.deleteRow(i + 1);
        return {
          status: 'success',
          message: 'Supplier deleted successfully'
        };
      }
    }
    
    return {
      status: 'error',
      message: 'Supplier not found'
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

// ==================== ITEM OPERATIONS ====================

function getItems() {
  try {
    const sheet = getSheet('Items');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const items = data.slice(1).map(row => {
      const item = {};
      headers.forEach((header, index) => {
        item[header] = row[index];
      });
      return item;
    }).filter(i => i.Item_ID);
    
    return {
      status: 'success',
      data: items
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function addItem(data) {
  try {
    const sheet = getSheet('Items');
    const itemId = generateId('ITM', sheet);
    
    const newRow = [
      itemId,
      data.description || '',
      data.supplierId || '',
      data.uom || 'EA',
      parseFloat(data.costPrice) || 0,
      parseFloat(data.sellPrice) || 0,
      parseInt(data.qtyOnHand) || 0,
      parseInt(data.reorderPoint) || 0,
      data.notes || ''
    ];
    
    sheet.appendRow(newRow);
    
    return {
      status: 'success',
      message: 'Item added successfully',
      itemId: itemId
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function updateItem(data) {
  try {
    const sheet = getSheet('Items');
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    
    for (let i = 1; i < values.length; i++) {
      if (values[i][0] === data.itemId) {
        sheet.getRange(i + 1, 2).setValue(data.description || values[i][1]);
        sheet.getRange(i + 1, 3).setValue(data.supplierId || values[i][2]);
        sheet.getRange(i + 1, 4).setValue(data.uom || values[i][3]);
        sheet.getRange(i + 1, 5).setValue(parseFloat(data.costPrice) || values[i][4]);
        sheet.getRange(i + 1, 6).setValue(parseFloat(data.sellPrice) || values[i][5]);
        if (data.qtyOnHand !== undefined) {
          sheet.getRange(i + 1, 7).setValue(parseInt(data.qtyOnHand));
        }
        sheet.getRange(i + 1, 8).setValue(parseInt(data.reorderPoint) || values[i][7]);
        sheet.getRange(i + 1, 9).setValue(data.notes || values[i][8]);
        
        return {
          status: 'success',
          message: 'Item updated successfully'
        };
      }
    }
    
    return {
      status: 'error',
      message: 'Item not found'
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function deleteItem(data) {
  try {
    const sheet = getSheet('Items');
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    
    for (let i = 1; i < values.length; i++) {
      if (values[i][0] === data.itemId) {
        sheet.deleteRow(i + 1);
        return {
          status: 'success',
          message: 'Item deleted successfully'
        };
      }
    }
    
    return {
      status: 'error',
      message: 'Item not found'
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

// ==================== CUSTOMER OPERATIONS ====================

function getCustomers() {
  try {
    const sheet = getSheet('Customers');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const customers = data.slice(1).map(row => {
      const customer = {};
      headers.forEach((header, index) => {
        customer[header] = row[index];
      });
      return customer;
    }).filter(c => c.Customer_ID);
    
    return {
      status: 'success',
      data: customers
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function addCustomer(data) {
  try {
    const sheet = getSheet('Customers');
    const customerId = generateId('C', sheet);
    
    const newRow = [
      customerId,
      data.name || '',
      data.address || '',
      data.city || '',
      data.state || '',
      data.zip || '',
      data.contactName || '',
      data.phone || '',
      data.email || '',
      parseFloat(data.creditLimit) || 0,
      data.paymentTerms || 'Net 30',
      data.notes || ''
    ];
    
    sheet.appendRow(newRow);
    
    return {
      status: 'success',
      message: 'Customer added successfully',
      customerId: customerId
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function updateCustomer(data) {
  try {
    const sheet = getSheet('Customers');
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    
    for (let i = 1; i < values.length; i++) {
      if (values[i][0] === data.customerId) {
        sheet.getRange(i + 1, 2).setValue(data.name || values[i][1]);
        sheet.getRange(i + 1, 3).setValue(data.address || values[i][2]);
        sheet.getRange(i + 1, 4).setValue(data.city || values[i][3]);
        sheet.getRange(i + 1, 5).setValue(data.state || values[i][4]);
        sheet.getRange(i + 1, 6).setValue(data.zip || values[i][5]);
        sheet.getRange(i + 1, 7).setValue(data.contactName || values[i][6]);
        sheet.getRange(i + 1, 8).setValue(data.phone || values[i][7]);
        sheet.getRange(i + 1, 9).setValue(data.email || values[i][8]);
        sheet.getRange(i + 1, 10).setValue(parseFloat(data.creditLimit) || values[i][9]);
        sheet.getRange(i + 1, 11).setValue(data.paymentTerms || values[i][10]);
        sheet.getRange(i + 1, 12).setValue(data.notes || values[i][11]);
        
        return {
          status: 'success',
          message: 'Customer updated successfully'
        };
      }
    }
    
    return {
      status: 'error',
      message: 'Customer not found'
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function deleteCustomer(data) {
  try {
    const sheet = getSheet('Customers');
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    
    for (let i = 1; i < values.length; i++) {
      if (values[i][0] === data.customerId) {
        sheet.deleteRow(i + 1);
        return {
          status: 'success',
          message: 'Customer deleted successfully'
        };
      }
    }
    
    return {
      status: 'error',
      message: 'Customer not found'
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

// ==================== PURCHASE ORDER OPERATIONS ====================

function createPurchaseOrder(data) {
  try {
    const poSheet = getSheet('Purchase_Orders');
    const polSheet = getSheet('Purchase_Order_Lines');
    const itemsSheet = getSheet('Items');
    const invAdjSheet = getSheet('Inventory_Adjustments');
    
    // Generate PO ID
    const year = new Date().getFullYear();
    const poId = 'PO-' + year + '-' + String(poSheet.getLastRow()).padStart(3, '0');
    
    // Add PO header
    const poRow = [
      poId,
      data.supplierId || '',
      new Date(),
      data.invoiceNumber || '',
      parseFloat(data.invoiceTotal) || 0,
      data.notes || ''
    ];
    poSheet.appendRow(poRow);
    
    // Add PO lines and update inventory
    if (data.lines && Array.isArray(data.lines)) {
      data.lines.forEach(line => {
        // Add line
        const polRow = [
          poId,
          line.itemId || '',
          parseInt(line.quantity) || 0,
          parseFloat(line.unitCost) || 0
        ];
        polSheet.appendRow(polRow);
        
        // Update inventory
        const itemData = itemsSheet.getDataRange().getValues();
        for (let i = 1; i < itemData.length; i++) {
          if (itemData[i][0] === line.itemId) {
            const currentQty = parseInt(itemData[i][6]) || 0;
            const newQty = currentQty + (parseInt(line.quantity) || 0);
            itemsSheet.getRange(i + 1, 7).setValue(newQty);
            
            // Log inventory adjustment
            const adjRow = [
              new Date(),
              line.itemId,
              'Purchase',
              poId,
              parseInt(line.quantity) || 0,
              currentQty,
              newQty,
              'Purchase order received'
            ];
            invAdjSheet.appendRow(adjRow);
            break;
          }
        }
      });
    }
    
    return {
      status: 'success',
      message: 'Purchase order created successfully',
      poId: poId
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function getPurchaseOrders() {
  try {
    const poSheet = getSheet('Purchase_Orders');
    const polSheet = getSheet('Purchase_Order_Lines');
    
    const poData = poSheet.getDataRange().getValues();
    const polData = polSheet.getDataRange().getValues();
    
    const orders = poData.slice(1).map(row => {
      const poId = row[0];
      const lines = polData.slice(1)
        .filter(l => l[0] === poId)
        .map(l => ({
          itemId: l[1],
          quantity: l[2],
          unitCost: l[3]
        }));
      
      return {
        PO_ID: poId,
        Supplier_ID: row[1],
        PO_Date: row[2],
        Invoice_Number: row[3],
        Invoice_Total: row[4],
        Notes: row[5],
        lines: lines
      };
    }).filter(po => po.PO_ID);
    
    return {
      status: 'success',
      data: orders
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

// ==================== SALES ORDER OPERATIONS ====================

function createSalesOrder(data) {
  try {
    const soSheet = getSheet('Sales_Orders');
    const solSheet = getSheet('Sales_Order_Lines');
    const itemsSheet = getSheet('Items');
    const invAdjSheet = getSheet('Inventory_Adjustments');
    
    // Generate SO ID
    const year = new Date().getFullYear();
    const soId = 'SO-' + year + '-' + String(soSheet.getLastRow()).padStart(3, '0');
    
    // Add SO header
    const soRow = [
      soId,
      data.customerId || '',
      new Date(),
      parseFloat(data.orderTotal) || 0,
      data.notes || ''
    ];
    soSheet.appendRow(soRow);
    
    // Add SO lines and update inventory
    if (data.lines && Array.isArray(data.lines)) {
      data.lines.forEach(line => {
        // Add line
        const solRow = [
          soId,
          line.itemId || '',
          parseInt(line.quantity) || 0,
          parseFloat(line.unitPrice) || 0
        ];
        solSheet.appendRow(solRow);
        
        // Update inventory (decrease)
        const itemData = itemsSheet.getDataRange().getValues();
        for (let i = 1; i < itemData.length; i++) {
          if (itemData[i][0] === line.itemId) {
            const currentQty = parseInt(itemData[i][6]) || 0;
            const newQty = currentQty - (parseInt(line.quantity) || 0);
            itemsSheet.getRange(i + 1, 7).setValue(newQty);
            
            // Log inventory adjustment
            const adjRow = [
              new Date(),
              line.itemId,
              'Sale',
              soId,
              -(parseInt(line.quantity) || 0),
              currentQty,
              newQty,
              'Sales order fulfilled'
            ];
            invAdjSheet.appendRow(adjRow);
            break;
          }
        }
      });
    }
    
    return {
      status: 'success',
      message: 'Sales order created successfully',
      soId: soId
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function getSalesOrders() {
  try {
    const soSheet = getSheet('Sales_Orders');
    const solSheet = getSheet('Sales_Order_Lines');
    
    const soData = soSheet.getDataRange().getValues();
    const solData = solSheet.getDataRange().getValues();
    
    const orders = soData.slice(1).map(row => {
      const soId = row[0];
      const lines = solData.slice(1)
        .filter(l => l[0] === soId)
        .map(l => ({
          itemId: l[1],
          quantity: l[2],
          unitPrice: l[3]
        }));
      
      return {
        SO_ID: soId,
        Customer_ID: row[1],
        SO_Date: row[2],
        Order_Total: row[3],
        Notes: row[4],
        lines: lines
      };
    }).filter(so => so.SO_ID);
    
    return {
      status: 'success',
      data: orders
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

// ==================== INVENTORY OPERATIONS ====================

function adjustInventory(data) {
  try {
    const itemsSheet = getSheet('Items');
    const invAdjSheet = getSheet('Inventory_Adjustments');
    
    const itemData = itemsSheet.getDataRange().getValues();
    for (let i = 1; i < itemData.length; i++) {
      if (itemData[i][0] === data.itemId) {
        const currentQty = parseInt(itemData[i][6]) || 0;
        const adjustment = parseInt(data.adjustment) || 0;
        const newQty = currentQty + adjustment;
        
        itemsSheet.getRange(i + 1, 7).setValue(newQty);
        
        // Log adjustment
        const adjRow = [
          new Date(),
          data.itemId,
          'Manual',
          data.reference || '',
          adjustment,
          currentQty,
          newQty,
          data.reason || 'Manual adjustment'
        ];
        invAdjSheet.appendRow(adjRow);
        
        return {
          status: 'success',
          message: 'Inventory adjusted successfully',
          oldQty: currentQty,
          newQty: newQty
        };
      }
    }
    
    return {
      status: 'error',
      message: 'Item not found'
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}

function getInventoryReport() {
  try {
    const itemsSheet = getSheet('Items');
    const data = itemsSheet.getDataRange().getValues();
    const headers = data[0];
    
    const inventory = data.slice(1).map(row => {
      const item = {};
      headers.forEach((header, index) => {
        item[header] = row[index];
      });
      
      // Calculate value
      item.Total_Value = (parseFloat(item.Qty_On_Hand) || 0) * (parseFloat(item.Cost_Price) || 0);
      
      // Check if low stock
      item.Low_Stock = (parseInt(item.Qty_On_Hand) || 0) <= (parseInt(item.Reorder_Point) || 0);
      
      return item;
    }).filter(i => i.Item_ID);
    
    return {
      status: 'success',
      data: inventory
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.toString()
    };
  }
}
